---
title: "Two Forms of Pre-rendering"
date: "2022-01-01"
intro: "This is a test of the potential intro to this article."
image: "/finite_state_machine.jpg"
---

# heading 1

<NoticeBox notice="This is a Notice" noticeType="note">
  There exist alternatives to pickle which can serialize more objects such as
  [dill](https://github.com/uqfoundation/dill).
</NoticeBox>

Tech debt—the two words engineers loathe more than deploying a “quick fix” on a Friday and product owners fear more than missing an OKR deadline.

Often, tech debt results from taking too many technical shortcuts when building out features. You know the drill: The product team creates an ambitious roadmap that leaves little room for error, and engineers hack on top of an already archaic software infrastructure to enable those ambitions. The debt creeps in like a child tiptoeing into the kitchen to sneak cookies from the pantry, resulting in a gradual erosion of your system’s efficiency—and a whole lot of crumbs to clean up. When quick and dirty hacks become an engineering organization’s default mode, it can be tough to advocate for doing things the “right” way, dedicating time and effort to formulating detailed requirements, building robust solutions, or automating manual tasks.

Paying down tech debt is frequently seen as the less glamorous, less exciting side of software engineering. Migrations aren’t fun, and neither is replacing old dependencies with new ones. New architectures don’t magically diagram themselves on your whiteboard overnight. But when left unexamined for too long, tech debt can go from a neglected nuisance to a catastrophic failure. In contrast, when addressed proactively, tech debt represents an opportunity to build resilience and robustness into our systems.

```python
{
  "firstName": "John",
  "lastName": "Smith",
  "age": 25
}
```

# heading2

Tech debt—the two words engineers loathe more than deploying a “quick fix” on a Friday and product owners fear more than missing an OKR deadline.

Often, tech debt results from taking too many technical shortcuts when building out features. You know the drill: The product team creates an ambitious roadmap that leaves little room for error, and engineers hack on top of an already archaic software infrastructure to enable those ambitions. The debt creeps in like a child tiptoeing into the kitchen to sneak cookies from the pantry, resulting in a gradual erosion of your system’s efficiency—and a whole lot of crumbs to clean up. When quick and dirty hacks become an engineering organization’s default mode, it can be tough to advocate for doing things the “right” way, dedicating time and effort to formulating detailed requirements, building robust solutions, or automating manual tasks.

Paying down tech debt is frequently seen as the less glamorous, less exciting side of software engineering. Migrations aren’t fun, and neither is replacing old dependencies with new ones. New architectures don’t magically diagram themselves on your whiteboard overnight. But when left unexamined for too long, tech debt can go from a neglected nuisance to a catastrophic failure. In contrast, when addressed proactively, tech debt represents an opportunity to build resilience and robustness into our systems.

```python
{
  "firstName": "John",
  "lastName": "Smith",
  "age": 25
}
```

Tech debt—the two words engineers loathe more than deploying a “quick fix” on a Friday and product owners fear more than missing an OKR deadline.

Often, tech debt results from taking too many technical shortcuts when building out features. You know the drill: The product team creates an ambitious roadmap that leaves little room for error, and engineers hack on top of an already archaic software infrastructure to enable those ambitions. The debt creeps in like a child tiptoeing into the kitchen to sneak cookies from the pantry, resulting in a gradual erosion of your system’s efficiency—and a whole lot of crumbs to clean up. When quick and dirty hacks become an engineering organization’s default mode, it can be tough to advocate for doing things the “right” way, dedicating time and effort to formulating detailed requirements, building robust solutions, or automating manual tasks.

Paying down tech debt is frequently seen as the less glamorous, less exciting side of software engineering. Migrations aren’t fun, and neither is replacing old dependencies with new ones. New architectures don’t magically diagram themselves on your whiteboard overnight. But when left unexamined for too long, tech debt can go from a neglected nuisance to a catastrophic failure. In contrast, when addressed proactively, tech debt represents an opportunity to build resilience and robustness into our systems.

```python
{
  "firstName": "John",
  "lastName": "Smith",
  "age": 25
}
```

Tech debt—the two words engineers loathe more than deploying a “quick fix” on a Friday and product owners fear more than missing an OKR deadline.

Often, tech debt results from taking too many technical shortcuts when building out features. You know the drill: The product team creates an ambitious roadmap that leaves little room for error, and engineers hack on top of an already archaic software infrastructure to enable those ambitions. The debt creeps in like a child tiptoeing into the kitchen to sneak cookies from the pantry, resulting in a gradual erosion of your system’s efficiency—and a whole lot of crumbs to clean up. When quick and dirty hacks become an engineering organization’s default mode, it can be tough to advocate for doing things the “right” way, dedicating time and effort to formulating detailed requirements, building robust solutions, or automating manual tasks.

Paying down tech debt is frequently seen as the less glamorous, less exciting side of software engineering. Migrations aren’t fun, and neither is replacing old dependencies with new ones. New architectures don’t magically diagram themselves on your whiteboard overnight. But when left unexamined for too long, tech debt can go from a neglected nuisance to a catastrophic failure. In contrast, when addressed proactively, tech debt represents an opportunity to build resilience and robustness into our systems.

```python
{
  "firstName": "John",
  "lastName": "Smith",
  "age": 25
}
```

Tech debt—the two words engineers loathe more than deploying a “quick fix” on a Friday and product owners fear more than missing an OKR deadline.

Often, tech debt results from taking too many technical shortcuts when building out features. You know the drill: The product team creates an ambitious roadmap that leaves little room for error, and engineers hack on top of an already archaic software infrastructure to enable those ambitions. The debt creeps in like a child tiptoeing into the kitchen to sneak cookies from the pantry, resulting in a gradual erosion of your system’s efficiency—and a whole lot of crumbs to clean up. When quick and dirty hacks become an engineering organization’s default mode, it can be tough to advocate for doing things the “right” way, dedicating time and effort to formulating detailed requirements, building robust solutions, or automating manual tasks.

Paying down tech debt is frequently seen as the less glamorous, less exciting side of software engineering. Migrations aren’t fun, and neither is replacing old dependencies with new ones. New architectures don’t magically diagram themselves on your whiteboard overnight. But when left unexamined for too long, tech debt can go from a neglected nuisance to a catastrophic failure. In contrast, when addressed proactively, tech debt represents an opportunity to build resilience and robustness into our systems.

```python
{
  "firstName": "John",
  "lastName": "Smith",
  "age": 25
}
```
